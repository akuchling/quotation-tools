#!/usr/bin/env python3
#
# qtformat
# Copyright 2002, 2013 Andrew M. Kuchling
#
# Reads a document in the QEL DTD, converting it to a list of Quotation
# objects.  The list can then be output in several formats.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import sys, argparse, random
import qel
from qel import parse, quotation

__doc__ = """Usage: %s [options] file1.xml file2.xml ...
If no filenames are provided, standard input will be read.
Output formats:
  -f or --fortune   Produce output for the fortune(1) program
  -h or --html      Produce HTML output
  -R or --rst       Produce RestructuredText output
  -t or --text      Produce plain text output
  -w or --wiki      Produce Wikiquote.org-style Wiki output
  -x or --xml       Produce pretty-printed QEL output
Other options:
  -m N or --max N   Suppress quotations longer than N lines;
                    defaults to 0, which suppresses no quotations at all.
  -r or --randomize Output quotations in random order
  -s N or --split N Divide the output into chunks of roughly N kilobytes;
                    the division is indicated by a line containing just
                    "NEW FILE 1/10"
""" % sys.argv[0]


def count_lines(qt, method):
    "Count the number of lines in a quotation's text representation."
    meth = getattr(qt, method)
    output = meth()
    return output.count('\n')


def main():
    # Parse options
    parser = argparse.ArgumentParser(description="Merge multiple QEL files")
    parser.add_argument('files', metavar='FILE', nargs='*',
                        help="files to process")
    parser.add_argument('-f', '--fortune', dest='output', action='store_const',
                        const='as_fortune',
                        default='as_fortune',
                        help='Produce output for the fortune(1) program')
    parser.add_argument('-H', '--html', dest='output', action='store_const',
                        const='as_html',
                        help='Produce HTML output')
    parser.add_argument('-R', '--rst', dest='output', action='store_const',
                        const='as_rst',
                        help='Produce reStructured Text output')
    parser.add_argument('-t', '--text', dest='output', action='store_const',
                        const='as_text',
                        help='Produce plain text output')
    parser.add_argument('-w', '--wiki', dest='output', action='store_const',
                        const='as_wiki',
                        help='Produce Wikiquote.org-style Wiki output')
    parser.add_argument('-x', '--xml', dest='output', action='store_const',
                        const='as_xml',
                        help='Produce pretty-printed QEL output')

    parser.add_argument('-m', '--max', dest='maxlength', metavar='N',
                        default=0, type=int,
                        help='''Suppress quotations longer than N lines;
                        defaults to 0, which suppresses no quotations at all.
                        '''),
    parser.add_argument('-s', '--split', dest='split_size',
                        default=None, type=int,
                        help='''Divide the output into chunks of roughly
                        N kilobytes; the division is indicated by a line
                        containing just "NEW FILE 1/10''')

    parser.add_argument('-r', '--randomize', dest='randomize',
                        action='store_true', default=False,
                        help='Output quotations in random order')

    args = parser.parse_args()
    if args.split_size is not None:
        # Convert from K to bytes.
        args.split_size *= 1024

    # Loop over the input files; use sys.stdin if no files are specified
    if len(args.files) == 0:
        args.files = [sys.stdin]

    output_qtcoll = None
    for file in args.files:
        if isinstance(file, str):
            stream = open(file, 'r')
        else:
            stream = file
        qtcoll = parse.parse(stream)
        if args.maxlength != 0:
            qtcoll = [qt for qt in qtcoll
                      if count_lines(qt, args.output) <= args.maxlength]
        if output_qtcoll is None:
            output_qtcoll = qtcoll
        else:
            output_qtcoll.extend(qtcoll)

    # Randomize the order of the quotations
    if args.randomize:
        random.shuffle(qtcoll)

    if args.output == 'as_xml':
        encoding = sys.getdefaultencoding()
        sys.stdout.write(qtcoll.as_xml(encoding))
        return

    # If we're splitting the output into several files, count up the
    # total number of files
    current_file_size = 0
    num_files = 1
    if args.split_size is not None:
        for quote in qtcoll:
            current_file_size += len(quote)
            if current_file_size > args.split_size:
                current_file_size = 0
                num_files += 1

    # Output the quotations
    current_file_size = 0
    if args.split_size is not None:
        print("NEW FILE 1/%i" % num_files)
        cur_file = 1

    for i in range(len(qtcoll)):
        quote = qtcoll[i]
        meth = getattr(quote, args.output)
        print(meth())
        current_file_size += len(quote)
        if (args.split_size is not None and
            current_file_size > args.split_size and
            i < len(qtcoll) - 1 ):
            current_file_size = current_file_size % args.split_size
            cur_file += 1
            print("NEW FILE %i/%i" % (cur_file, num_files))
    # We're done!

if __name__ == '__main__':
    main()
